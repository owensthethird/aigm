{"ast":null,"code":"var _WebSocketService;\n/**\n * WebSocketService - Handles real-time communication with the AI backend\n * Uses Socket.io client with automatic reconnection and event handling\n */\nclass WebSocketService {\n  // Default server URL for native WebSocket\n\n  constructor() {\n    this.socket = null;\n    this.status = 'disconnected';\n    this.messageListeners = [];\n    this.statusListeners = [];\n    this.reconnectAttempts = 0;\n    this.maxReconnectAttempts = 10;\n    this.reconnectDelay = 1000;\n    // Start with 1 second\n    this.baseUrl = 'ws://localhost:3000';\n  }\n  static getInstance() {\n    if (!WebSocketService.instance) {\n      WebSocketService.instance = new WebSocketService();\n    }\n    return WebSocketService.instance;\n  }\n  init(url = this.baseUrl) {\n    if (url) this.baseUrl = url;\n    this.connect();\n  }\n  connect() {\n    if (this.socket && (this.status === 'connected' || this.status === 'connecting')) return;\n    this.updateStatus('connecting');\n    try {\n      this.socket = new WebSocket(this.baseUrl);\n    } catch (err) {\n      this.updateStatus('error');\n      this.attemptReconnect();\n      return;\n    }\n    this.setupEventListeners();\n  }\n  setupEventListeners() {\n    if (!this.socket) return;\n    this.socket.onopen = () => {\n      this.reconnectAttempts = 0;\n      this.reconnectDelay = 1000;\n      this.updateStatus('connected');\n    };\n    this.socket.onclose = () => {\n      this.updateStatus('disconnected');\n      this.attemptReconnect();\n    };\n    this.socket.onerror = err => {\n      console.error('WebSocket connection error:', err);\n      this.updateStatus('error');\n      this.attemptReconnect();\n    };\n    this.socket.onmessage = event => {\n      let data = null;\n      try {\n        data = JSON.parse(event.data);\n      } catch (e) {\n        // Ignore non-JSON\n        return;\n      }\n      if (data && typeof data === 'object' && 'type' in data) {\n        this.handleMessage(data);\n      }\n    };\n  }\n\n  /**\n   * Handle incoming messages and notify subscribers\n   */\n  handleMessage(message) {\n    this.messageListeners.forEach(listener => listener(message));\n  }\n\n  /**\n   * Update connection status and notify subscribers\n   */\n  updateStatus(status) {\n    this.status = status;\n    this.statusListeners.forEach(listener => listener(status));\n  }\n\n  /**\n   * Attempt to reconnect with exponential backoff\n   */\n  attemptReconnect() {\n    if (this.reconnectAttempts >= this.maxReconnectAttempts) {\n      this.updateStatus('error');\n      return;\n    }\n    this.reconnectAttempts++;\n    this.reconnectDelay = Math.min(this.reconnectDelay * 2, 30000); // Cap at 30 seconds\n    setTimeout(() => {\n      this.connect();\n    }, this.reconnectDelay + Math.random() * 1000); // Add jitter\n  }\n\n  /**\n   * Send a message to the server\n   */\n  sendMessage(message) {\n    if (this.socket && this.status === 'connected') {\n      this.socket.send(JSON.stringify(message));\n    } else {\n      console.error('Cannot send message, socket not connected');\n    }\n  }\n\n  /**\n   * Subscribe to all messages\n   * @returns Unsubscribe function\n   */\n  subscribeToMessages(callback) {\n    this.messageListeners.push(callback);\n    return () => {\n      this.messageListeners = this.messageListeners.filter(cb => cb !== callback);\n    };\n  }\n\n  /**\n   * Subscribe to connection status updates\n   * @returns Unsubscribe function\n   */\n  subscribeToStatus(callback) {\n    this.statusListeners.push(callback);\n    // Immediately notify with current status\n    callback(this.status);\n    return () => {\n      this.statusListeners = this.statusListeners.filter(cb => cb !== callback);\n    };\n  }\n\n  /**\n   * Get current connection status\n   */\n  getStatus() {\n    return this.status;\n  }\n\n  /**\n   * Disconnect from WebSocket server\n   */\n  disconnect() {\n    if (this.socket) {\n      this.socket.close();\n      this.socket = null;\n    }\n    this.updateStatus('disconnected');\n  }\n}\n_WebSocketService = WebSocketService;\nWebSocketService.instance = void 0;\nexport default WebSocketService;","map":{"version":3,"names":["WebSocketService","constructor","socket","status","messageListeners","statusListeners","reconnectAttempts","maxReconnectAttempts","reconnectDelay","baseUrl","getInstance","instance","init","url","connect","updateStatus","WebSocket","err","attemptReconnect","setupEventListeners","onopen","onclose","onerror","console","error","onmessage","event","data","JSON","parse","e","handleMessage","message","forEach","listener","Math","min","setTimeout","random","sendMessage","send","stringify","subscribeToMessages","callback","push","filter","cb","subscribeToStatus","getStatus","disconnect","close","_WebSocketService"],"sources":["C:/Users/Shadow/Documents/Cursor/aiGM/ui/src/services/WebSocketService.ts"],"sourcesContent":["\nexport type ConnectionStatus = 'connected' | 'connecting' | 'disconnected' | 'error';\n\nexport type MessageType = 'message' | 'typing' | 'provider_status' | 'error' | 'system';\n\nexport interface WebSocketMessage {\n  type: MessageType;\n  payload: any;\n  timestamp: number;\n}\n\nexport interface ProviderStatusUpdate {\n  providerId: string;\n  status: 'healthy' | 'unhealthy' | 'connecting' | 'disconnected';\n}\n\ntype MessageListener = (message: WebSocketMessage) => void;\ntype StatusListener = (status: ConnectionStatus) => void;\n\n/**\n * WebSocketService - Handles real-time communication with the AI backend\n * Uses Socket.io client with automatic reconnection and event handling\n */\nclass WebSocketService {\n  private static instance: WebSocketService;\n  private socket: WebSocket | null = null;\n  private status: ConnectionStatus = 'disconnected';\n  private messageListeners: MessageListener[] = [];\n  private statusListeners: StatusListener[] = [];\n  private reconnectAttempts = 0;\n  private maxReconnectAttempts = 10;\n  private reconnectDelay = 1000; // Start with 1 second\n  private baseUrl = 'ws://localhost:3000'; // Default server URL for native WebSocket\n\n  private constructor() {}\n\n  public static getInstance(): WebSocketService {\n    if (!WebSocketService.instance) {\n      WebSocketService.instance = new WebSocketService();\n    }\n    return WebSocketService.instance;\n  }\n\n  public init(url: string = this.baseUrl): void {\n    if (url) this.baseUrl = url;\n    this.connect();\n  }\n\n  private connect(): void {\n    if (this.socket && (this.status === 'connected' || this.status === 'connecting')) return;\n    this.updateStatus('connecting');\n    try {\n      this.socket = new WebSocket(this.baseUrl);\n    } catch (err) {\n      this.updateStatus('error');\n      this.attemptReconnect();\n      return;\n    }\n    this.setupEventListeners();\n  }\n\n  private setupEventListeners(): void {\n    if (!this.socket) return;\n    this.socket.onopen = () => {\n      this.reconnectAttempts = 0;\n      this.reconnectDelay = 1000;\n      this.updateStatus('connected');\n    };\n    this.socket.onclose = () => {\n      this.updateStatus('disconnected');\n      this.attemptReconnect();\n    };\n    this.socket.onerror = (err: Event) => {\n      console.error('WebSocket connection error:', err);\n      this.updateStatus('error');\n      this.attemptReconnect();\n    };\n    this.socket.onmessage = (event: MessageEvent) => {\n      let data: WebSocketMessage | null = null;\n      try {\n        data = JSON.parse(event.data);\n      } catch (e) {\n        // Ignore non-JSON\n        return;\n      }\n      if (data && typeof data === 'object' && 'type' in data) {\n        this.handleMessage(data as WebSocketMessage);\n      }\n    };\n  }\n\n  /**\n   * Handle incoming messages and notify subscribers\n   */\n  private handleMessage(message: WebSocketMessage): void {\n    this.messageListeners.forEach(listener => listener(message));\n  }\n\n  /**\n   * Update connection status and notify subscribers\n   */\n  private updateStatus(status: ConnectionStatus): void {\n    this.status = status;\n    this.statusListeners.forEach(listener => listener(status));\n  }\n\n  /**\n   * Attempt to reconnect with exponential backoff\n   */\n  private attemptReconnect(): void {\n    if (this.reconnectAttempts >= this.maxReconnectAttempts) {\n      this.updateStatus('error');\n      return;\n    }\n    this.reconnectAttempts++;\n    this.reconnectDelay = Math.min(this.reconnectDelay * 2, 30000); // Cap at 30 seconds\n    setTimeout(() => {\n      this.connect();\n    }, this.reconnectDelay + Math.random() * 1000); // Add jitter\n  }\n\n  /**\n   * Send a message to the server\n   */\n  public sendMessage(message: any): void {\n    if (this.socket && this.status === 'connected') {\n      this.socket.send(JSON.stringify(message));\n    } else {\n      console.error('Cannot send message, socket not connected');\n    }\n  }\n\n  /**\n   * Subscribe to all messages\n   * @returns Unsubscribe function\n   */\n  public subscribeToMessages(callback: MessageListener): () => void {\n    this.messageListeners.push(callback);\n    return () => {\n      this.messageListeners = this.messageListeners.filter(cb => cb !== callback);\n    };\n  }\n\n  /**\n   * Subscribe to connection status updates\n   * @returns Unsubscribe function\n   */\n  public subscribeToStatus(callback: StatusListener): () => void {\n    this.statusListeners.push(callback);\n    // Immediately notify with current status\n    callback(this.status);\n    return () => {\n      this.statusListeners = this.statusListeners.filter(cb => cb !== callback);\n    };\n  }\n\n  /**\n   * Get current connection status\n   */\n  public getStatus(): ConnectionStatus {\n    return this.status;\n  }\n\n  /**\n   * Disconnect from WebSocket server\n   */\n  public disconnect(): void {\n    if (this.socket) {\n      this.socket.close();\n      this.socket = null;\n    }\n    this.updateStatus('disconnected');\n  }\n}\n\nexport default WebSocketService;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}