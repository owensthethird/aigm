{"ast":null,"code":"var _WebSocketService;\n/**\n * WebSocketService - Handles real-time communication with the AI backend\n * Uses native WebSocket API with automatic reconnection and event handling\n */\nclass WebSocketService {\n  // Default server URL (using WebSocket protocol)\n\n  constructor() {\n    this.socket = null;\n    this.status = 'disconnected';\n    this.messageListeners = [];\n    this.statusListeners = [];\n    this.reconnectAttempts = 0;\n    this.maxReconnectAttempts = 10;\n    this.reconnectDelay = 1000;\n    // Start with 1 second\n    this.baseUrl = 'ws://localhost:3000';\n  } // Private constructor for singleton pattern\n\n  /**\n   * Get singleton instance of WebSocketService\n   */\n  static getInstance() {\n    if (!WebSocketService.instance) {\n      WebSocketService.instance = new WebSocketService();\n    }\n    return WebSocketService.instance;\n  }\n\n  /**\n   * Initialize the WebSocket connection\n   * @param url Server URL to connect to\n   */\n  init(url = this.baseUrl) {\n    if (url) {\n      // Ensure URL uses ws:// or wss:// protocol\n      if (!url.startsWith('ws://') && !url.startsWith('wss://')) {\n        this.baseUrl = `ws://${url.replace(/^https?:\\/\\//, '')}`;\n      } else {\n        this.baseUrl = url;\n      }\n    }\n    this.connect();\n  }\n\n  /**\n   * Connect to WebSocket server\n   */\n  connect() {\n    if (this.socket) {\n      // If socket exists but is not open, close it first\n      if (this.socket.readyState !== WebSocket.OPEN) {\n        this.socket.close();\n        this.socket = null;\n      } else {\n        return; // Already connected\n      }\n    }\n    this.updateStatus('connecting');\n    try {\n      this.socket = new WebSocket(this.baseUrl);\n      this.setupEventListeners();\n    } catch (error) {\n      console.error('WebSocket connection error:', error);\n      this.updateStatus('error');\n      this.attemptReconnect();\n    }\n  }\n\n  /**\n   * Setup native WebSocket event listeners\n   */\n  setupEventListeners() {\n    if (!this.socket) return;\n    this.socket.onopen = () => {\n      this.reconnectAttempts = 0;\n      this.reconnectDelay = 1000;\n      this.updateStatus('connected');\n      console.log('WebSocket connection established');\n    };\n    this.socket.onclose = event => {\n      console.log(`WebSocket connection closed: ${event.code} ${event.reason}`);\n      this.updateStatus('disconnected');\n      this.attemptReconnect();\n    };\n    this.socket.onerror = error => {\n      console.error('WebSocket connection error:', error);\n      this.updateStatus('error');\n      // Error usually followed by close event which will trigger reconnect\n    };\n\n    // Handle all incoming messages through the onmessage handler\n    this.socket.onmessage = event => {\n      try {\n        // Try to parse as JSON\n        const data = JSON.parse(event.data);\n\n        // Handle as WebSocketMessage if it has the right format\n        if (data && typeof data === 'object' && 'type' in data) {\n          const message = {\n            type: data.type,\n            payload: data.payload || data.data,\n            // Support both formats\n            timestamp: data.timestamp || Date.now()\n          };\n          this.handleMessage(message);\n        } else {\n          console.warn('Received message in unexpected format:', data);\n          // Still notify with a generic message type\n          this.handleMessage({\n            type: 'message',\n            payload: data,\n            timestamp: Date.now()\n          });\n        }\n      } catch (error) {\n        // Handle plain text or non-JSON data\n        console.warn('Received non-JSON message:', event.data);\n        this.handleMessage({\n          type: 'message',\n          payload: event.data,\n          timestamp: Date.now()\n        });\n      }\n    };\n  }\n\n  /**\n   * Handle incoming messages and notify subscribers\n   */\n  handleMessage(message) {\n    this.messageListeners.forEach(listener => listener(message));\n  }\n\n  /**\n   * Update connection status and notify subscribers\n   */\n  updateStatus(status) {\n    this.status = status;\n    this.statusListeners.forEach(listener => listener(status));\n  }\n\n  /**\n   * Attempt to reconnect with exponential backoff\n   */\n  attemptReconnect() {\n    if (this.reconnectAttempts >= this.maxReconnectAttempts) {\n      console.error('Max reconnection attempts reached');\n      this.updateStatus('error');\n      return;\n    }\n\n    // Calculate backoff delay with jitter for distributed reconnection\n    const jitter = Math.random() * 0.5 + 0.75; // Random between 0.75 and 1.25\n    const delay = Math.min(this.reconnectDelay * jitter, 30000); // Cap at 30 seconds\n\n    console.log(`Attempting to reconnect in ${Math.round(delay / 1000)}s`);\n\n    // Increment for next attempt if needed\n    this.reconnectAttempts++;\n    this.reconnectDelay *= 1.5; // Exponential backoff\n\n    setTimeout(() => {\n      // For WebSocket, we need to create a new connection\n      // Close existing socket if it's still there\n      if (this.socket) {\n        try {\n          this.socket.close();\n        } catch (e) {\n          // Ignore errors during close\n        }\n        this.socket = null;\n      }\n      // Create a new connection\n      this.connect();\n    }, delay);\n  }\n\n  /**\n   * Send message to the server\n   */\n  sendMessage(message) {\n    if (this.socket && this.status === 'connected') {\n      try {\n        // Convert message to JSON string\n        const messageString = JSON.stringify(message);\n        this.socket.send(messageString);\n      } catch (error) {\n        console.error('Failed to send message:', error);\n      }\n    } else {\n      console.error('Cannot send message, socket not connected');\n    }\n  }\n\n  /**\n   * Subscribe to all messages\n   * @returns Unsubscribe function\n   */\n  subscribeToMessages(callback) {\n    this.messageListeners.push(callback);\n    return () => {\n      this.messageListeners = this.messageListeners.filter(cb => cb !== callback);\n    };\n  }\n\n  /**\n   * Subscribe to connection status updates\n   * @returns Unsubscribe function\n   */\n  subscribeToStatus(callback) {\n    this.statusListeners.push(callback);\n    // Immediately notify with current status\n    callback(this.status);\n    return () => {\n      this.statusListeners = this.statusListeners.filter(cb => cb !== callback);\n    };\n  }\n\n  /**\n   * Get current connection status\n   */\n  getStatus() {\n    return this.status;\n  }\n\n  /**\n   * Disconnect from the server\n   */\n  disconnect() {\n    if (this.socket) {\n      try {\n        this.socket.close();\n        this.socket = null;\n        this.updateStatus('disconnected');\n      } catch (error) {\n        console.error('Error while disconnecting:', error);\n      }\n    }\n  }\n}\n_WebSocketService = WebSocketService;\nWebSocketService.instance = void 0;\nexport default WebSocketService;","map":{"version":3,"names":["WebSocketService","constructor","socket","status","messageListeners","statusListeners","reconnectAttempts","maxReconnectAttempts","reconnectDelay","baseUrl","getInstance","instance","init","url","startsWith","replace","connect","readyState","WebSocket","OPEN","close","updateStatus","setupEventListeners","error","console","attemptReconnect","onopen","log","onclose","event","code","reason","onerror","onmessage","data","JSON","parse","message","type","payload","timestamp","Date","now","handleMessage","warn","forEach","listener","jitter","Math","random","delay","min","round","setTimeout","e","sendMessage","messageString","stringify","send","subscribeToMessages","callback","push","filter","cb","subscribeToStatus","getStatus","disconnect","_WebSocketService"],"sources":["C:/users/shadow/Documents/cursor/aigm/ui/src/services/WebSocketService.ts"],"sourcesContent":["export type ConnectionStatus = 'connected' | 'connecting' | 'disconnected' | 'error';\n\nexport type MessageType = 'message' | 'typing' | 'provider_status' | 'error' | 'system';\n\nexport interface WebSocketMessage {\n  type: MessageType;\n  payload?: any;\n  data?: any; // For backward compatibility\n  timestamp?: number;\n}\n\nexport interface ProviderStatusUpdate {\n  providerId: string;\n  status: 'healthy' | 'unhealthy' | 'connecting' | 'disconnected';\n}\n\ntype MessageListener = (message: WebSocketMessage) => void;\ntype StatusListener = (status: ConnectionStatus) => void;\n\n/**\n * WebSocketService - Handles real-time communication with the AI backend\n * Uses native WebSocket API with automatic reconnection and event handling\n */\nclass WebSocketService {\n  private static instance: WebSocketService;\n  private socket: WebSocket | null = null;\n  private status: ConnectionStatus = 'disconnected';\n  private messageListeners: MessageListener[] = [];\n  private statusListeners: StatusListener[] = [];\n  private reconnectAttempts = 0;\n  private maxReconnectAttempts = 10;\n  private reconnectDelay = 1000; // Start with 1 second\n  private baseUrl = 'ws://localhost:3000'; // Default server URL (using WebSocket protocol)\n\n  private constructor() {\n    // Private constructor for singleton pattern\n  }\n\n  /**\n   * Get singleton instance of WebSocketService\n   */\n  public static getInstance(): WebSocketService {\n    if (!WebSocketService.instance) {\n      WebSocketService.instance = new WebSocketService();\n    }\n    return WebSocketService.instance;\n  }\n\n  /**\n   * Initialize the WebSocket connection\n   * @param url Server URL to connect to\n   */\n  public init(url: string = this.baseUrl): void {\n    if (url) {\n      // Ensure URL uses ws:// or wss:// protocol\n      if (!url.startsWith('ws://') && !url.startsWith('wss://')) {\n        this.baseUrl = `ws://${url.replace(/^https?:\\/\\//, '')}`;\n      } else {\n        this.baseUrl = url;\n      }\n    }\n    this.connect();\n  }\n\n  /**\n   * Connect to WebSocket server\n   */\n  private connect(): void {\n    if (this.socket) {\n      // If socket exists but is not open, close it first\n      if (this.socket.readyState !== WebSocket.OPEN) {\n        this.socket.close();\n        this.socket = null;\n      } else {\n        return; // Already connected\n      }\n    }\n    \n    this.updateStatus('connecting');\n    \n    try {\n      this.socket = new WebSocket(this.baseUrl);\n      this.setupEventListeners();\n    } catch (error) {\n      console.error('WebSocket connection error:', error);\n      this.updateStatus('error');\n      this.attemptReconnect();\n    }\n  }\n\n  /**\n   * Setup native WebSocket event listeners\n   */\n  private setupEventListeners(): void {\n    if (!this.socket) return;\n\n    this.socket.onopen = () => {\n      this.reconnectAttempts = 0;\n      this.reconnectDelay = 1000;\n      this.updateStatus('connected');\n      console.log('WebSocket connection established');\n    };\n\n    this.socket.onclose = (event) => {\n      console.log(`WebSocket connection closed: ${event.code} ${event.reason}`);\n      this.updateStatus('disconnected');\n      this.attemptReconnect();\n    };\n\n    this.socket.onerror = (error) => {\n      console.error('WebSocket connection error:', error);\n      this.updateStatus('error');\n      // Error usually followed by close event which will trigger reconnect\n    };\n\n    // Handle all incoming messages through the onmessage handler\n    this.socket.onmessage = (event: MessageEvent) => {\n      try {\n        // Try to parse as JSON\n        const data = JSON.parse(event.data);\n        \n        // Handle as WebSocketMessage if it has the right format\n        if (data && typeof data === 'object' && 'type' in data) {\n          const message: WebSocketMessage = {\n            type: data.type,\n            payload: data.payload || data.data, // Support both formats\n            timestamp: data.timestamp || Date.now()\n          };\n          \n          this.handleMessage(message);\n        } else {\n          console.warn('Received message in unexpected format:', data);\n          // Still notify with a generic message type\n          this.handleMessage({\n            type: 'message',\n            payload: data,\n            timestamp: Date.now()\n          });\n        }\n      } catch (error) {\n        // Handle plain text or non-JSON data\n        console.warn('Received non-JSON message:', event.data);\n        this.handleMessage({\n          type: 'message', \n          payload: event.data,\n          timestamp: Date.now()\n        });\n      }\n    };\n  }\n\n  /**\n   * Handle incoming messages and notify subscribers\n   */\n  private handleMessage(message: WebSocketMessage): void {\n    this.messageListeners.forEach(listener => listener(message));\n  }\n\n  /**\n   * Update connection status and notify subscribers\n   */\n  private updateStatus(status: ConnectionStatus): void {\n    this.status = status;\n    this.statusListeners.forEach(listener => listener(status));\n  }\n\n  /**\n   * Attempt to reconnect with exponential backoff\n   */\n  private attemptReconnect(): void {\n    if (this.reconnectAttempts >= this.maxReconnectAttempts) {\n      console.error('Max reconnection attempts reached');\n      this.updateStatus('error');\n      return;\n    }\n\n    // Calculate backoff delay with jitter for distributed reconnection\n    const jitter = Math.random() * 0.5 + 0.75; // Random between 0.75 and 1.25\n    const delay = Math.min(this.reconnectDelay * jitter, 30000); // Cap at 30 seconds\n    \n    console.log(`Attempting to reconnect in ${Math.round(delay / 1000)}s`);\n    \n    // Increment for next attempt if needed\n    this.reconnectAttempts++;\n    this.reconnectDelay *= 1.5; // Exponential backoff\n    \n    setTimeout(() => {\n      // For WebSocket, we need to create a new connection\n      // Close existing socket if it's still there\n      if (this.socket) {\n        try {\n          this.socket.close();\n        } catch (e) {\n          // Ignore errors during close\n        }\n        this.socket = null;\n      }\n      // Create a new connection\n      this.connect();\n    }, delay);\n  }\n\n  /**\n   * Send message to the server\n   */\n  public sendMessage(message: any): void {\n    if (this.socket && this.status === 'connected') {\n      try {\n        // Convert message to JSON string\n        const messageString = JSON.stringify(message);\n        this.socket.send(messageString);\n      } catch (error) {\n        console.error('Failed to send message:', error);\n      }\n    } else {\n      console.error('Cannot send message, socket not connected');\n    }\n  }\n\n  /**\n   * Subscribe to all messages\n   * @returns Unsubscribe function\n   */\n  public subscribeToMessages(callback: MessageListener): () => void {\n    this.messageListeners.push(callback);\n    return () => {\n      this.messageListeners = this.messageListeners.filter(cb => cb !== callback);\n    };\n  }\n\n  /**\n   * Subscribe to connection status updates\n   * @returns Unsubscribe function\n   */\n  public subscribeToStatus(callback: StatusListener): () => void {\n    this.statusListeners.push(callback);\n    // Immediately notify with current status\n    callback(this.status);\n    return () => {\n      this.statusListeners = this.statusListeners.filter(cb => cb !== callback);\n    };\n  }\n\n  /**\n   * Get current connection status\n   */\n  public getStatus(): ConnectionStatus {\n    return this.status;\n  }\n\n  /**\n   * Disconnect from the server\n   */\n  public disconnect(): void {\n    if (this.socket) {\n      try {\n        this.socket.close();\n        this.socket = null;\n        this.updateStatus('disconnected');\n      } catch (error) {\n        console.error('Error while disconnecting:', error);\n      }\n    }\n  }\n}\n\nexport default WebSocketService;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}